(ns mccawley-bulk.squirrel
  (:require [clojure.zip :as z]))

;; From https://en.wikipedia.org/wiki/C-command
;;
;; The definition of c-command is based partly on the relationship of dominance:
;; Node N1 dominates node N2 if N1 is above N2 in the tree and one can trace a
;; path from N1 to N2 moving only downwards in the tree (never upwards); that is,
;; if N1 is a parent, grandparent, etc. of N2.

;; Based upon this definition of dominance, node A c-commands node B if and only if:

;; 1. A does not dominate B,
;; 2. B does not dominate A, and
;; 3. The first (i.e. lowest) branching node that dominates A also dominates B.[2]

;; Because 1 and 2 never apply to words in trees generated by McCawley,
;; we just concern ourselves with determining the lowest branching node of A
;; and checking if it dominates B.


(defn get-node-location [tree node]
  "Assumes tree is a zipper and node is a map.
   Returns the zipper 'location' for the node requested."
    (loop [current-node tree]
      (cond
        (-> current-node z/end?)
          nil
        (= (:word node) (str (first current-node)))
          current-node
        (= node (str (first current-node)))
          current-node
        :else
          (recur (->> current-node z/next)))))


(defn is-branching-node? [node]
  (if (not (seq? (first node)))
    false
    (->> node first rest count (< 1))))


(defn get-lowest-branching-node [node]
  "node refers to the zipper location."
   (loop [current-node node]
      (cond
        (nil? current-node)
          nil
        (is-branching-node? current-node)
          current-node
        :else
          (recur (->> current-node z/up)))))


(defn is-node-dominated? [dominator-candidate dominated-candidate]
  "each node refers to the location of a node in a given zipper."
  (loop [current-node dominated-candidate]
    (cond
      (nil? current-node)
        false
      (= dominator-candidate current-node)
        true
      :else
        (recur (->> current-node z/up)))))


(defn c-command [tree node-a node-b]
  (let [node-a-lowest-branching-node (->> (get-node-location tree node-a)
                                          get-lowest-branching-node)
        node-b-starting-point (get-node-location tree node-b)]
    (is-node-dominated? node-a-lowest-branching-node
                        node-b-starting-point)))


(defn get-all-zipper-nodes [tree]
  "Assumes tree is a zipper."
  (loop [all-nodes []
         current-node tree]
    (if (-> current-node z/end?)
      all-nodes
      (recur (conj all-nodes current-node)
             (->> current-node z/next)))))
